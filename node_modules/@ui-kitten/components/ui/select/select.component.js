/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import React from 'react';
import { Animated, Platform, StyleSheet, TouchableOpacity, View, } from 'react-native';
import { Interaction, styled, } from '../../theme';
import { SelectOptionsList, } from './selectOptionsList.component';
import { Text, } from '../text/text.component';
import { Popover } from '../popover/popover.component';
import { ChevronDown, } from '../support/components/chevronDown.component';
import { allWithPrefix, isValidString, WebEventResponder, } from '../support/services';
import { SelectService } from './select.service';
/**
 * Styled `Select` component. By default, the MultiSelect compares the items by reference.
 * To specify a field from the data object which will be used for the comparison,
 * implement the `keyExtractor` property.
 *
 * @extends React.Component
 *
 * @method {() => void} show - Sets options list visible.
 *
 * @method {() => void} hide - Sets options list invisible.
 *
 * @method {() => void} focus - Focuses Select and sets options list visible.
 *
 * @method {() => void} blur - Removes focus from Select and sets options list invisible.
 * This is the opposite of `focus()`.
 *
 * @method {() => boolean} isFocused - Returns true if the Select is currently focused and visible.
 *
 * @method {() => void} clear - Removes all text from the Select.
 *
 * @property {string} status - Determines the status of the component.
 * Can be `basic`, `primary`, `success`, `info`, `warning`, `danger` or `control`.
 * Default is `basic`.
 *
 * @property {string} size - Determines the size of the component.
 * Can be `small`, `medium` or `large`.
 * Default is `medium`.
 *
 * @property {boolean} disabled - Determines whether component is disabled.
 * Default is `false.
 *
 * @property {boolean} multiSelect - Determines `multi-select` behavior of the Select component.
 *
 * @property {SelectOption} selectedOption - Determines selected option of the Select.
 * Can be `SelectOptionType` or `SelectOptionType[]` It depends on `multiSelect` property.
 *
 * @property {SelectOptionType[]} data - Determines items of the Select component.
 *
 * @property {(option: SelectOption, event?: GestureResponderEvent) => void} onSelect - Fires on option select.
 * Returns selected option/options.
 *
 * @property {StyleProp<TextStyle>} label - Determines the `label` of the component.
 *
 * @property {StyleProp<TextStyle>} placeholder - Determines the `placeholder` of the component.
 * By default is `Select Option`.
 *
 * @property {StyleProp<TextStyle>} labelStyle - Determines the style of the `label`.
 *
 * @property {StyleProp<TextStyle>} placeholderStyle - Determines the style of the `placeholder`.
 *
 * @property {StyleProp<TextStyle>} textStyle - Determines the style of the selected option/options text.
 *
 * @property {StyleProp<ViewStyle>} controlStyle - Determines the style of `control`.
 *
 * @property {(style: StyleType) => ReactElement} icon - Determines icon of the component.
 *
 * @property {StyleProp<TextStyle>} textStyle - Customizes text style.
 *
 * @property {KeyExtractorType} keyExtractor - Used to extract a unique key for a given item;
 *
 * @property {TouchableOpacityProps} ...TouchableOpacityProps - Any props applied to TouchableOpacity component.
 *
 * @overview-example SelectSimpleUsage
 *
 * @overview-example SelectStates
 *
 * @overview-example SelectStatus
 *
 * @overview-example SelectSize
 *
 * @overview-example SelectMultiSelect
 *
 * @overview-example SelectWithGroups
 *
 * @overview-example SelectDisabledOptions
 *
 * @example SelectInitialValue
 *
 * @example SelectMultiInitialValue
 *
 * @example SelectCustomIcon
 *
 * @example SelectInlineStyling
 */
class SelectComponent extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            optionsVisible: false,
        };
        this.popoverRef = React.createRef();
        this.webEventResponder = WebEventResponder.create(this);
        this.iconAnimation = new Animated.Value(0);
        this.selectService = new SelectService({
            multiSelect: this.props.multiSelect,
            keyExtractor: this.props.keyExtractor,
        });
        this.show = () => {
            this.popoverRef.current.show();
        };
        this.hide = () => {
            this.popoverRef.current.hide();
        };
        this.focus = () => {
            this.setState({ optionsVisible: true }, this.onOptionsListVisible);
        };
        this.blur = () => {
            this.setState({ optionsVisible: false }, this.onOptionsListInvisible);
        };
        this.isFocused = () => {
            return this.state.optionsVisible;
        };
        this.clear = () => {
            if (this.props.onSelect) {
                this.props.onSelect(null);
            }
        };
        // WebEventResponderCallbacks
        this.onMouseEnter = () => {
            if (!this.state.optionsVisible) {
                this.props.dispatch([Interaction.HOVER]);
            }
        };
        this.onMouseLeave = () => {
            if (!this.state.optionsVisible) {
                this.props.dispatch([]);
            }
        };
        this.onFocus = () => {
            this.props.dispatch([Interaction.FOCUSED]);
        };
        this.onBlur = () => {
            this.props.dispatch([]);
        };
        this.onPress = (event) => {
            this.setOptionsListVisible();
            if (this.props.onPress) {
                this.props.onPress(event);
            }
        };
        this.onPressIn = (event) => {
            this.props.dispatch([Interaction.ACTIVE]);
            if (this.props.onPressIn) {
                this.props.onPressIn(event);
            }
        };
        this.onPressOut = (event) => {
            this.props.dispatch([]);
            if (this.props.onPressOut) {
                this.props.onPressOut(event);
            }
        };
        this.onSelect = (option, event) => {
            if (this.props.onSelect) {
                const options = this.selectService.select(option, this.props.selectedOption);
                !this.props.multiSelect && this.setOptionsListInvisible();
                this.props.onSelect(options, event);
            }
        };
        this.onOptionsListVisible = () => {
            this.props.dispatch([Interaction.ACTIVE]);
            this.createIconAnimation(-180).start();
        };
        this.onOptionsListInvisible = () => {
            this.props.dispatch([]);
            this.createIconAnimation(0).start();
        };
        this.setOptionsListVisible = () => {
            this.setState({ optionsVisible: true }, this.onOptionsListVisible);
        };
        this.setOptionsListInvisible = () => {
            this.setState({ optionsVisible: false }, this.onOptionsListInvisible);
        };
        this.isOptionSelected = (option) => {
            return this.selectService.isSelected(option, this.props.selectedOption);
        };
        this.isOptionGroup = (option) => {
            return SelectService.isGroup(option);
        };
        this.createIconAnimation = (toValue) => {
            return Animated.timing(this.iconAnimation, {
                toValue: toValue,
                duration: 200,
            });
        };
        this.getComponentStyle = (source) => {
            const { backgroundColor, borderColor, borderWidth, minHeight, paddingHorizontal, paddingVertical, borderRadius, } = source;
            const iconStyles = allWithPrefix(source, 'icon');
            const textStyles = allWithPrefix(source, 'text');
            const placeholderStyles = allWithPrefix(source, 'placeholder');
            const popoverStyles = allWithPrefix(source, 'popover');
            const labelStyle = allWithPrefix(source, 'label');
            return {
                control: {
                    backgroundColor: backgroundColor,
                    borderColor: borderColor,
                    borderWidth: borderWidth,
                    minHeight: minHeight,
                    paddingHorizontal: paddingHorizontal,
                    paddingVertical: paddingVertical,
                    borderRadius: borderRadius,
                },
                icon: {
                    height: iconStyles.iconHeight,
                    width: iconStyles.iconWidth,
                    marginHorizontal: iconStyles.iconMarginHorizontal,
                    tintColor: iconStyles.iconTintColor,
                },
                text: {
                    marginHorizontal: textStyles.textMarginHorizontal,
                    color: textStyles.textColor,
                    fontSize: textStyles.textFontSize,
                    fontWeight: textStyles.textFontWeight,
                    lineHeight: textStyles.textLineHeight,
                    fontFamily: textStyles.textFontFamily,
                },
                placeholder: {
                    marginHorizontal: placeholderStyles.placeholderMarginHorizontal,
                    color: placeholderStyles.placeholderColor,
                    fontSize: placeholderStyles.placeholderFontSize,
                    fontWeight: placeholderStyles.placeholderFontWeight,
                    lineHeight: placeholderStyles.placeholderLineHeight,
                    fontFamily: placeholderStyles.placeholderFontFamily,
                },
                popover: {
                    maxHeight: popoverStyles.popoverMaxHeight,
                    borderRadius: popoverStyles.popoverBorderRadius,
                    borderColor: popoverStyles.popoverBorderColor,
                    borderWidth: popoverStyles.popoverBorderWidth,
                },
                label: {
                    marginBottom: labelStyle.labelMarginBottom,
                    color: labelStyle.labelColor,
                    fontSize: labelStyle.labelFontSize,
                    fontWeight: labelStyle.labelFontWeight,
                    lineHeight: labelStyle.labelLineHeight,
                    fontFamily: labelStyle.labelFontFamily,
                },
            };
        };
        this.renderLabelElement = (style) => {
            return (React.createElement(Text, { style: [style, this.props.labelStyle] }, this.props.label));
        };
        this.renderDefaultIconElement = (style) => {
            const rotateInterpolate = this.iconAnimation.interpolate({
                inputRange: [-180, 0],
                outputRange: ['-180deg', '0deg'],
            });
            const animatedStyle = { transform: [{ rotate: rotateInterpolate }] };
            const { tintColor, ...svgStyle } = style;
            return (React.createElement(Animated.View, { style: animatedStyle },
                React.createElement(ChevronDown, Object.assign({ fill: tintColor }, svgStyle))));
        };
        this.renderIconElement = (style) => {
            const iconElement = this.props.icon(style, this.state.optionsVisible);
            return React.cloneElement(iconElement, {
                style: [style, iconElement.props.style],
            });
        };
        this.renderTextElement = (style) => {
            const value = this.selectService.toStringOptions(this.props.selectedOption);
            const textStyle = value && style.text;
            return (React.createElement(Text, { style: [styles.text, style.placeholder, textStyle, this.props.textStyle], numberOfLines: 1, ellipsizeMode: 'tail' }, value || this.props.placeholder));
        };
        this.renderOptionsListElement = (style) => {
            return (React.createElement(SelectOptionsList, { key: 0, style: [styles.optionsList, style], data: this.props.data, multiSelect: this.props.multiSelect, isOptionSelected: this.isOptionSelected, isOptionGroup: this.isOptionGroup, onSelect: this.onSelect, keyExtractor: this.props.keyExtractor }));
        };
        this.renderControlChildren = (style) => {
            const iconElement = this.props.icon && this.renderIconElement(style.icon);
            return [
                iconElement || this.renderDefaultIconElement(style.icon),
                this.renderTextElement(style),
            ];
        };
        this.renderControlElement = (style) => {
            const { themedStyle, controlStyle, ...restProps } = this.props;
            const [iconElement, textElement] = this.renderControlChildren(style);
            return (React.createElement(TouchableOpacity, Object.assign({ activeOpacity: 1.0 }, restProps, this.webEventResponder.eventHandlers, { style: [styles.control, style.control, webStyles.control, controlStyle], onPress: this.onPress, onPressIn: this.onPressIn, onPressOut: this.onPressOut }),
                textElement,
                iconElement));
        };
        this.renderComponentChildren = (style) => {
            return [
                this.renderOptionsListElement(style.optionsList),
                isValidString(this.props.label) && this.renderLabelElement(style.label),
                this.renderControlElement(style),
            ];
        };
    }
    render() {
        const { themedStyle, style } = this.props;
        const { popover, ...componentStyle } = this.getComponentStyle(themedStyle);
        const [optionsListElement, labelElement, controlElement,] = this.renderComponentChildren(componentStyle);
        return (React.createElement(View, { style: style },
            labelElement,
            React.createElement(Popover, { ref: this.popoverRef, style: [popover, styles.popover], fullWidth: true, visible: this.state.optionsVisible, content: optionsListElement, onBackdropPress: this.setOptionsListInvisible }, controlElement)));
    }
}
SelectComponent.styledComponentName = 'Select';
SelectComponent.defaultProps = {
    placeholder: 'Select Option',
    multiSelect: false,
};
const styles = StyleSheet.create({
    control: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
    },
    text: {
        flex: 1,
    },
    optionsList: {
        flexGrow: 0,
    },
    popover: {
        overflow: 'hidden',
    },
});
const webStyles = Platform.OS === 'web' && StyleSheet.create({
    control: {
        // @ts-ignore
        outlineWidth: 0,
    },
});
export const Select = styled(SelectComponent);
//# sourceMappingURL=select.component.js.map