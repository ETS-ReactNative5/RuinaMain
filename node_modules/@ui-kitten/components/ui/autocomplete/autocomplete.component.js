/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import React from 'react';
import { StyleSheet, View, } from 'react-native';
import { Input, } from '../input/input.component';
import { List, } from '../list/list.component';
import { ListItem, } from '../list/listItem.component';
import { Popover, } from '../popover/popover.component';
/**
 * Autocomplete is a normal text input enhanced by a panel of suggested options.
 *
 * @extends React.Component
 *
 * @method {() => void} show - Sets data list visible.
 *
 * @method {() => void} hide - Sets data list invisible.
 *
 * @method {() => void} focus - Focuses Autocomplete and sets data list visible.
 *
 * @method {() => void} blur - Removes focus from Autocomplete and sets data list invisible.
 * This is the opposite of `focus()`.
 *
 * @method {() => boolean} isFocused - Returns true if the Autocomplete is currently focused and visible.
 *
 * @method {() => void} clear - Removes all text from the Autocomplete.
 *
 * @property {AutocompleteOption[]} data - Options displayed in component.
 * Each option can be any type, but should contain `title` property.
 *
 * @property {AutocompleteOption[]} placeholderData - Options displayed in component
 * when data is nullable of empty.
 *
 * @property {(option: AutocompleteOption) => void} onSelect - Emits when option is pressed.
 *
 * @property {(info: ListRenderItemInfo<AutocompleteOption>) => ReactElement} renderItem - Takes an
 * item from data and renders it into the list. If not provided, ListItem is rendered.
 *
 * @property {InputProps} ...InputProps - Any props applied to Input component.
 *
 * @overview-example AutocompleteSimpleUsage
 *
 * @overview-example AutocompleteStates
 *
 * @overview-example AutocompleteStatus
 *
 * @overview-example AutocompleteSize
 *
 * @overview-example AutocompleteWithIcon
 *
 * @overview-example AutocompleteWithLabel
 *
 * @example AutocompleteAsync
 */
export class Autocomplete extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            optionsVisible: false,
        };
        this.popoverRef = React.createRef();
        this.inputRef = React.createRef();
        this.show = () => {
            this.popoverRef.current.show();
        };
        this.hide = () => {
            this.popoverRef.current.hide();
        };
        this.focus = () => {
            this.inputRef.current.focus();
        };
        this.blur = () => {
            this.inputRef.current.blur();
        };
        this.isFocused = () => {
            return this.inputRef.current.isFocused();
        };
        this.clear = () => {
            this.inputRef.current.clear();
        };
        this.onInputFocus = (e) => {
            this.setState({ optionsVisible: true });
            if (this.props.onFocus) {
                this.props.onFocus(e);
            }
        };
        this.onBackdropPress = () => {
            this.setState({ optionsVisible: false });
        };
        this.onOptionPress = (index) => {
            if (this.props.onSelect) {
                this.props.onSelect(this.props.data[index]);
                this.setState({ optionsVisible: false });
            }
        };
        this.renderOptionElement = (info) => {
            return (React.createElement(ListItem, { title: info.item.title, onPress: this.onOptionPress }));
        };
        this.renderCustomOptionElement = (info) => {
            return (React.createElement(ListItem, { onPress: this.onOptionPress }, this.props.renderItem(info)));
        };
        this.renderInputElement = (props) => {
            return (React.createElement(Input, Object.assign({ ref: this.inputRef }, props, { onFocus: this.onInputFocus })));
        };
        this.renderComponentChildren = (props) => {
            const { data, renderItem, placeholderData, ...inputProps } = props;
            return [
                this.renderInputElement(inputProps),
                this.renderOptionListElement({ data, renderItem }),
            ];
        };
    }
    get data() {
        const hasData = this.props.data && this.props.data.length > 0;
        return hasData && this.props.data || this.props.placeholderData;
    }
    renderOptionListElement(props) {
        return (React.createElement(List, Object.assign({ style: styles.optionList }, props, { data: this.data, bounces: false, renderItem: props.renderItem && this.renderCustomOptionElement || this.renderOptionElement })));
    }
    render() {
        const [inputElement, listElement] = this.renderComponentChildren(this.props);
        return (React.createElement(Popover, { ref: this.popoverRef, style: styles.popover, visible: this.state.optionsVisible, fullWidth: true, content: listElement, onBackdropPress: this.onBackdropPress },
            React.createElement(View, null, inputElement)));
    }
}
const styles = StyleSheet.create({
    popover: {
        maxHeight: 192,
        overflow: 'hidden',
    },
    optionList: {
        flexGrow: 0,
        overflow: 'hidden',
    },
});
//# sourceMappingURL=autocomplete.component.js.map